{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction The ugly red book is my personal Digital Garden . Its my place to share and grow my knowledge base of things I know or have learned in my professional journey. Somethings will be interesting to the reader and others will be completely pointless.. but they are important enough to me to warrant them being enshrined here in the garden. If this is your first time \"picking up\" the ugly red book, awesome and welcome Carl! You might be in for a treat.. or you'll spend your entire time wondering what's wrong with me and creating issues on GitHub for all the typos and bad grammar. FAQ Q: Can I contribute to your garden? A: Sure Carl! Feel free to drop in a Pull Request with your contribution and I'll take a look. See below for more details Q: Why do you call this the \"\"Ugly Red Book\"\"? A: Because it won't fit on a shelf. Duh! Q: Huh? A: ... Q: What is the picture from? A: Umm.. Carl, we need to talk about your upbringing. How is it you have never heard of the \"Ugly red book that won't fit on a shelf\" and you don't know what that image is from? Did you live under a rock in the mid-nineties and never see the amazing movie Hackers ? Q: OH! My dad really liked that movie. I always thought is was a bit dumb and the story made no sense. Also what's up with that weird \"Techno\" music. A: I hate you Carl! Q: Are there any dumb questions? A: Nope! Q: Why do you keep calling me Carl? A: Stop asking dumb questions Carl. Q: How often do you update this? A: When I want to or I learn something interesting that I think should be added. Q: No really, why do you keep calling me Carl? A: DAMMIT CARL! We've talk about this before . Contributing Coming soon... \"This is the end, my friend. Thank you for Calling.\" -- The Plague","title":"Home"},{"location":"#_1","text":"","title":""},{"location":"#introduction","text":"The ugly red book is my personal Digital Garden . Its my place to share and grow my knowledge base of things I know or have learned in my professional journey. Somethings will be interesting to the reader and others will be completely pointless.. but they are important enough to me to warrant them being enshrined here in the garden. If this is your first time \"picking up\" the ugly red book, awesome and welcome Carl! You might be in for a treat.. or you'll spend your entire time wondering what's wrong with me and creating issues on GitHub for all the typos and bad grammar.","title":"Introduction"},{"location":"#faq","text":"Q: Can I contribute to your garden? A: Sure Carl! Feel free to drop in a Pull Request with your contribution and I'll take a look. See below for more details Q: Why do you call this the \"\"Ugly Red Book\"\"? A: Because it won't fit on a shelf. Duh! Q: Huh? A: ... Q: What is the picture from? A: Umm.. Carl, we need to talk about your upbringing. How is it you have never heard of the \"Ugly red book that won't fit on a shelf\" and you don't know what that image is from? Did you live under a rock in the mid-nineties and never see the amazing movie Hackers ? Q: OH! My dad really liked that movie. I always thought is was a bit dumb and the story made no sense. Also what's up with that weird \"Techno\" music. A: I hate you Carl! Q: Are there any dumb questions? A: Nope! Q: Why do you keep calling me Carl? A: Stop asking dumb questions Carl. Q: How often do you update this? A: When I want to or I learn something interesting that I think should be added. Q: No really, why do you keep calling me Carl? A: DAMMIT CARL! We've talk about this before .","title":"FAQ"},{"location":"#contributing","text":"Coming soon... \"This is the end, my friend. Thank you for Calling.\" -- The Plague","title":"Contributing"},{"location":"Coding/C%2B%2B/FYI/","text":"Random FYIs This page is dedicated to random \"byte\" sized pieces of information that I've learned over time. Wide Characters A wide character is a computer character datatype that generally has a size greater than the traditional 8-bit character. The increased datatype size allows for the use of larger coded character sets. ( source ) Wide char is similar to char data type, except that wide char take up twice the space and can take on much larger values as a result. char can take 256 values which corresponds to entries in the ASCII table. On the other hand, wide char can take on 65536 values which corresponds to UNICODE values. ( source ) Just like the type for character constants is char, the type for wide character is wchar_t. This data type occupies 2 or 4 bytes depending on the compiler being used. Mostly the wchar_t datatype is used when international languages like Japanese are used. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> using namespace std ; int main () { // char type array string char name [] = \"FOOBAR\" ; cout << name << endl ; // wide-char type array string wchar_t wname [] = L \"FOOBAR\" ; wcout << wname << endl ; return 0 ; }","title":"Random FYIs"},{"location":"Coding/C%2B%2B/FYI/#random-fyis","text":"This page is dedicated to random \"byte\" sized pieces of information that I've learned over time.","title":"Random FYIs"},{"location":"Coding/C%2B%2B/FYI/#wide-characters","text":"A wide character is a computer character datatype that generally has a size greater than the traditional 8-bit character. The increased datatype size allows for the use of larger coded character sets. ( source ) Wide char is similar to char data type, except that wide char take up twice the space and can take on much larger values as a result. char can take 256 values which corresponds to entries in the ASCII table. On the other hand, wide char can take on 65536 values which corresponds to UNICODE values. ( source ) Just like the type for character constants is char, the type for wide character is wchar_t. This data type occupies 2 or 4 bytes depending on the compiler being used. Mostly the wchar_t datatype is used when international languages like Japanese are used.","title":"Wide Characters"},{"location":"Coding/C%2B%2B/FYI/#example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> using namespace std ; int main () { // char type array string char name [] = \"FOOBAR\" ; cout << name << endl ; // wide-char type array string wchar_t wname [] = L \"FOOBAR\" ; wcout << wname << endl ; return 0 ; }","title":"Example"},{"location":"Coding/C%2B%2B/FYI/#_1","text":"","title":""},{"location":"Coding/Python/anti-patterns/","text":"Common Anti-Patterns Ok Carl, here's the thing, Python gives you all the tools necessary to build a gun and shoot yourself in the foot. Here are a list of things you shouldn't really do. Assigning a variable or function to a built-in At any time you can override one of Python's builtin function by assigning a variable to function to the same name as the builtin. Now.. there are some very RARE cases where you might want to do this and for this reason Python offers the builtin module to help with changing the behavior of a builtin. But most of the time.. just don't it Carl. Python Built-in Functions BAD 1 2 3 4 5 6 # Overwriting id with some value id = \"FOO\" # Now try to get the ID of some other object test = \"BAR\" print ( id ( test )) # TypeError: 'str' object is not callable GOOD 1 2 3 4 5 6 # Overwriting id with some value _id = \"FOO\" # Now try to get the ID of some other object test = \"BAR\" print ( id ( test )) # > 140614531283184 Not using with to open files Hey Carl, did you know that everytime you open a file object without closing a cat pushes a breakable object off a counter? Do you know why? Because cats are assholes.. What does that have to do with file objects? Nothing. What can you do make sure you always close your files and not be an asshole like those cats? Use the with context manager. What is a context manager? Go read this: Context Manager in Python - GeeksforGeeks So Carl do you get it now? With the with context manager, you're guaranteed that when your code goes out of scope, the file object will be automatically closed. BAD 1 2 3 filePointer = open ( \"test.txt\" ) data = filePointer . read () # Do stuff and never close your file GOOD 1 2 with open ( \"test.txt\" ) as filePointer : data = filePointer . read () Returning more than one object type from a function Ok Carl, I'll be honest, this is one of those \"Do as I say, not as I do.\" In a perfect world, you shouldn't return more than one object type from a function/method. However, it's pretty common to return None if the object you want to return can't be. For example, a method that gets some resource from the internet. if the resource isn't available, you COULD return None to indicate that it failed. However, this means that your caller need to be aware of and handle the None objects. A better solution would be to either raise an exception (faster) or return an invalid version of your object type if you can. BAD 1 2 3 def test ( inputValue : bool ): if inputValue : return \"FOO\" Note This is a bit tricky to the unfamiliar. In python this method will return a None type object if the inputValue doesn't evaluate as true. GOOD 1 2 3 4 5 6 7 8 9 10 11 12 class Foo ( object ): def __init__ ( self , value : str = None ): self . value = value def is_valid ( self ): return self . value is not None def test ( inputValue ): if inputValue : return Foo ( \"FOO\" ) return Foo () Note This is a bit long winded but it's consistent in that we are always returning an object of type Foo BETTER 1 2 3 4 def test ( inputValue : bool ): if inputValue : return \"FOO\" raise ValueError ( \"inputValue was not accepted\" ) Note Caller will need to wrap code in try/except. This means they will need to know your function can raise a ValueError. However this is faster than always checking for a None type; since we'll only hit the exception clause when the test method raises. Asking for permission instead of forgiveness Ok, yes Carl, I know you should usually ask for permission before you do something but that's not how we roll in Python. Here we live in the land of duck-typing so we just assume everything works and go for it! Or as the official python docs put it EAFP! BAD 1 2 if \"key\" in foo : value = foo [ \"key\" ] GOOD 1 2 3 4 try : value = foo [ \"key\" ] except KeyError : pass Bad Excepts Don't do this unless you have a damn good reason. BAD 1 2 3 4 try : foo () except : print ( \"FOO raised\" ) GOOD 1 2 3 4 5 6 try : foo () except RuntimeError : print ( \"FOO raised RuntimeError\" ) except ValueError : print ( \"FOO raised ValueError\" ) Method could be a Function You might have seen this error if you've run pylint on your code. Honestly, this is one that I'm not a huge fan of but it is good practice. So I'll cover it here. First off, what does this mean? The simple version is that you've written a method as part of a custom class that doesn't use the self argument and therefore \"probably\" should be a staticmethod/classmethod OR a independent function. Second, why does this warning get raised. Mostly its python's way of asking \"Are you sure this method needs to be defined as part of this class?\" Python is second guessing you and asking if you meant to do that or are you an idiot Carl? Python's pretty judgy.. BAD 1 2 3 4 5 6 class Foo ( object ): def __init__ ( self ): self . foo = \"FOO\" def bar ( self ): return \"BAR\" GOOD 1 2 3 4 5 6 class Foo ( object ): def __init__ ( self ): self . foo = \"FOO\" def bar (): return \"BAR\" Mutable default values as arguments Oh man, Carl, you have no idea how many times have I seen this one from junior devs or TDs that aren't super familiar with the python languege. It's really easy to think that you can set any default value to an argument. However, mutable default arguments (such as list) can come back to bite you in the ass. So I would recommend you don't this.. ever! BAD 1 2 3 4 5 6 7 def foo ( value : list = []): value . append ( 1 ) return value print ( foo ([ 123 ])) # [123, 1] print ( foo ()) # [1] print ( foo ()) # [1, 1] GOOD 1 2 3 4 5 6 7 8 9 def foo ( value : list = None ): if value is None : value = [] value . append ( 1 ) return value print ( foo ([ 123 ])) # [123, 1] print ( foo ()) # [1] print ( foo ()) # [1,] Wildcard imports Sigh.. I should really create a sub-list called Python Anti-Patterns called \"Do as I say, not as I do.\" This is another case where you \"shouldn't\" do this but.. sometimes it's just easier or makes sense. First, you may ask, what is a wildcard import? Simply, it's when you import every class/function/variable from a module in a single line: 1 from Foo import * Now you ask, why shouldn't I do that? Its way easier to type that one line than type the X number of imports to bring in the classes or functions I need from Foo. And you're right, it is easier. But.. easier isn't always better Carl. The big problem with that one-liner is that it also brings in all the stuff from Foo you might NOT want. What if in Foo there was a function called bool ? By using the wildcard import you're now are replacing the built-in bool function with Foo . bool and this can have pretty significant consequences. So when using imports always make sure you import only what you need and nothing else. Note Yep, you can absolutely overwrite python built in functions. Try it sometime, it's scary as hell. BAD 1 from Foo import * GOOD 1 2 3 from Foo import bar from Foo import foo from Foo import FooBar Using single letters to name variables This one is simple. Do I even need to give an example? BAD 1 2 3 c = 1 d = 2 e = 3 GOOD 1 2 3 cat = 1 dog = 2 eagle = 3 # Yeah I couldn't think of anything better Using type() to compare types Ok, sure you COULD do a type() string comparison but why? That's so pass\u00e9 BAD 1 2 3 4 5 6 7 class Foo ( object ): pass foo = Foo () if type ( foo ) == Foo : print ( \"SAME TYPE\" ) GOOD 1 2 3 4 5 6 7 class Foo ( object ): pass foo = Foo () if isinstance ( foo , Foo ): print ( \"SAME TYPE\" ) Incorrectly comparing None This is a bit odd if you're use to other languages such as C++. In other languages when you want to compare a variable to a Null value you would typically use the standard comparison operator == . And while you can do this, it's not the \"pythonic\" way. In python, None is an object (like almost everything else). More importantly None is a singleton object, which means all instances of None are the same object. Yep Carl, you know what that means! We should use the is operator. Note If you're not familiar with the is operator, check out This Bad 1 2 3 foo = None if foo == None : print ( \"FOO IS NONE\" ) GOOD 1 2 3 foo = None if foo is None : print ( \"FOO IS NONE\" ) Using built-in function to initialize list/dict/tuple This is more of a pet-peeve but don't use the list/dict/tuple keywords. BAD 1 2 3 foo = list () bar = dict () foobar = tuple () GOOD 1 2 3 foo = [] bar = {} foobar = () Also, FWIW, using the brackets instead of the function calls is faster! 1 2 3 4 5 6 7 8 9 10 11 import timeit slow = \"\"\" test = tuple() \"\"\" fast = \"\"\" test = () \"\"\" print ( timeit . timeit ( stmt = slow , number = 1000000 )) print ( timeit . timeit ( stmt = fast , number = 1000000 )) Not following PEP8 Last but not least, not following PEP8 is one of the worst crimes against python you can make. Carl... If you do this.. You're DEAD to me! PEP 8 -- Style Guide for Python Code | Python.org","title":"Common Anti-Patterns"},{"location":"Coding/Python/anti-patterns/#common-anti-patterns","text":"Ok Carl, here's the thing, Python gives you all the tools necessary to build a gun and shoot yourself in the foot. Here are a list of things you shouldn't really do.","title":"Common Anti-Patterns"},{"location":"Coding/Python/anti-patterns/#assigning-a-variable-or-function-to-a-built-in","text":"At any time you can override one of Python's builtin function by assigning a variable to function to the same name as the builtin. Now.. there are some very RARE cases where you might want to do this and for this reason Python offers the builtin module to help with changing the behavior of a builtin. But most of the time.. just don't it Carl. Python Built-in Functions","title":"Assigning a variable or function to a built-in"},{"location":"Coding/Python/anti-patterns/#bad","text":"1 2 3 4 5 6 # Overwriting id with some value id = \"FOO\" # Now try to get the ID of some other object test = \"BAR\" print ( id ( test )) # TypeError: 'str' object is not callable","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good","text":"1 2 3 4 5 6 # Overwriting id with some value _id = \"FOO\" # Now try to get the ID of some other object test = \"BAR\" print ( id ( test )) # > 140614531283184","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#not-using-with-to-open-files","text":"Hey Carl, did you know that everytime you open a file object without closing a cat pushes a breakable object off a counter? Do you know why? Because cats are assholes.. What does that have to do with file objects? Nothing. What can you do make sure you always close your files and not be an asshole like those cats? Use the with context manager. What is a context manager? Go read this: Context Manager in Python - GeeksforGeeks So Carl do you get it now? With the with context manager, you're guaranteed that when your code goes out of scope, the file object will be automatically closed.","title":"Not using with to open files"},{"location":"Coding/Python/anti-patterns/#bad_1","text":"1 2 3 filePointer = open ( \"test.txt\" ) data = filePointer . read () # Do stuff and never close your file","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_1","text":"1 2 with open ( \"test.txt\" ) as filePointer : data = filePointer . read ()","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#returning-more-than-one-object-type-from-a-function","text":"Ok Carl, I'll be honest, this is one of those \"Do as I say, not as I do.\" In a perfect world, you shouldn't return more than one object type from a function/method. However, it's pretty common to return None if the object you want to return can't be. For example, a method that gets some resource from the internet. if the resource isn't available, you COULD return None to indicate that it failed. However, this means that your caller need to be aware of and handle the None objects. A better solution would be to either raise an exception (faster) or return an invalid version of your object type if you can.","title":"Returning more than one object type from a function"},{"location":"Coding/Python/anti-patterns/#bad_2","text":"1 2 3 def test ( inputValue : bool ): if inputValue : return \"FOO\" Note This is a bit tricky to the unfamiliar. In python this method will return a None type object if the inputValue doesn't evaluate as true.","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Foo ( object ): def __init__ ( self , value : str = None ): self . value = value def is_valid ( self ): return self . value is not None def test ( inputValue ): if inputValue : return Foo ( \"FOO\" ) return Foo () Note This is a bit long winded but it's consistent in that we are always returning an object of type Foo","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#better","text":"1 2 3 4 def test ( inputValue : bool ): if inputValue : return \"FOO\" raise ValueError ( \"inputValue was not accepted\" ) Note Caller will need to wrap code in try/except. This means they will need to know your function can raise a ValueError. However this is faster than always checking for a None type; since we'll only hit the exception clause when the test method raises.","title":"BETTER"},{"location":"Coding/Python/anti-patterns/#asking-for-permission-instead-of-forgiveness","text":"Ok, yes Carl, I know you should usually ask for permission before you do something but that's not how we roll in Python. Here we live in the land of duck-typing so we just assume everything works and go for it! Or as the official python docs put it EAFP!","title":"Asking for permission instead of forgiveness"},{"location":"Coding/Python/anti-patterns/#bad_3","text":"1 2 if \"key\" in foo : value = foo [ \"key\" ]","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_3","text":"1 2 3 4 try : value = foo [ \"key\" ] except KeyError : pass","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#bad-excepts","text":"Don't do this unless you have a damn good reason.","title":"Bad Excepts"},{"location":"Coding/Python/anti-patterns/#bad_4","text":"1 2 3 4 try : foo () except : print ( \"FOO raised\" )","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_4","text":"1 2 3 4 5 6 try : foo () except RuntimeError : print ( \"FOO raised RuntimeError\" ) except ValueError : print ( \"FOO raised ValueError\" )","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#method-could-be-a-function","text":"You might have seen this error if you've run pylint on your code. Honestly, this is one that I'm not a huge fan of but it is good practice. So I'll cover it here. First off, what does this mean? The simple version is that you've written a method as part of a custom class that doesn't use the self argument and therefore \"probably\" should be a staticmethod/classmethod OR a independent function. Second, why does this warning get raised. Mostly its python's way of asking \"Are you sure this method needs to be defined as part of this class?\" Python is second guessing you and asking if you meant to do that or are you an idiot Carl? Python's pretty judgy..","title":"Method could be a Function"},{"location":"Coding/Python/anti-patterns/#bad_5","text":"1 2 3 4 5 6 class Foo ( object ): def __init__ ( self ): self . foo = \"FOO\" def bar ( self ): return \"BAR\"","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_5","text":"1 2 3 4 5 6 class Foo ( object ): def __init__ ( self ): self . foo = \"FOO\" def bar (): return \"BAR\"","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#mutable-default-values-as-arguments","text":"Oh man, Carl, you have no idea how many times have I seen this one from junior devs or TDs that aren't super familiar with the python languege. It's really easy to think that you can set any default value to an argument. However, mutable default arguments (such as list) can come back to bite you in the ass. So I would recommend you don't this.. ever!","title":"Mutable default values as arguments"},{"location":"Coding/Python/anti-patterns/#bad_6","text":"1 2 3 4 5 6 7 def foo ( value : list = []): value . append ( 1 ) return value print ( foo ([ 123 ])) # [123, 1] print ( foo ()) # [1] print ( foo ()) # [1, 1]","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_6","text":"1 2 3 4 5 6 7 8 9 def foo ( value : list = None ): if value is None : value = [] value . append ( 1 ) return value print ( foo ([ 123 ])) # [123, 1] print ( foo ()) # [1] print ( foo ()) # [1,]","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#wildcard-imports","text":"Sigh.. I should really create a sub-list called Python Anti-Patterns called \"Do as I say, not as I do.\" This is another case where you \"shouldn't\" do this but.. sometimes it's just easier or makes sense. First, you may ask, what is a wildcard import? Simply, it's when you import every class/function/variable from a module in a single line: 1 from Foo import * Now you ask, why shouldn't I do that? Its way easier to type that one line than type the X number of imports to bring in the classes or functions I need from Foo. And you're right, it is easier. But.. easier isn't always better Carl. The big problem with that one-liner is that it also brings in all the stuff from Foo you might NOT want. What if in Foo there was a function called bool ? By using the wildcard import you're now are replacing the built-in bool function with Foo . bool and this can have pretty significant consequences. So when using imports always make sure you import only what you need and nothing else. Note Yep, you can absolutely overwrite python built in functions. Try it sometime, it's scary as hell.","title":"Wildcard imports"},{"location":"Coding/Python/anti-patterns/#bad_7","text":"1 from Foo import *","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_7","text":"1 2 3 from Foo import bar from Foo import foo from Foo import FooBar","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#using-single-letters-to-name-variables","text":"This one is simple. Do I even need to give an example?","title":"Using single letters to name variables"},{"location":"Coding/Python/anti-patterns/#bad_8","text":"1 2 3 c = 1 d = 2 e = 3","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_8","text":"1 2 3 cat = 1 dog = 2 eagle = 3 # Yeah I couldn't think of anything better","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#using-type-to-compare-types","text":"Ok, sure you COULD do a type() string comparison but why? That's so pass\u00e9","title":"Using type() to compare types"},{"location":"Coding/Python/anti-patterns/#bad_9","text":"1 2 3 4 5 6 7 class Foo ( object ): pass foo = Foo () if type ( foo ) == Foo : print ( \"SAME TYPE\" )","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_9","text":"1 2 3 4 5 6 7 class Foo ( object ): pass foo = Foo () if isinstance ( foo , Foo ): print ( \"SAME TYPE\" )","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#incorrectly-comparing-none","text":"This is a bit odd if you're use to other languages such as C++. In other languages when you want to compare a variable to a Null value you would typically use the standard comparison operator == . And while you can do this, it's not the \"pythonic\" way. In python, None is an object (like almost everything else). More importantly None is a singleton object, which means all instances of None are the same object. Yep Carl, you know what that means! We should use the is operator. Note If you're not familiar with the is operator, check out This","title":"Incorrectly comparing None"},{"location":"Coding/Python/anti-patterns/#bad_10","text":"1 2 3 foo = None if foo == None : print ( \"FOO IS NONE\" )","title":"Bad"},{"location":"Coding/Python/anti-patterns/#good_10","text":"1 2 3 foo = None if foo is None : print ( \"FOO IS NONE\" )","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#using-built-in-function-to-initialize-listdicttuple","text":"This is more of a pet-peeve but don't use the list/dict/tuple keywords.","title":"Using built-in function to initialize list/dict/tuple"},{"location":"Coding/Python/anti-patterns/#bad_11","text":"1 2 3 foo = list () bar = dict () foobar = tuple ()","title":"BAD"},{"location":"Coding/Python/anti-patterns/#good_11","text":"1 2 3 foo = [] bar = {} foobar = () Also, FWIW, using the brackets instead of the function calls is faster! 1 2 3 4 5 6 7 8 9 10 11 import timeit slow = \"\"\" test = tuple() \"\"\" fast = \"\"\" test = () \"\"\" print ( timeit . timeit ( stmt = slow , number = 1000000 )) print ( timeit . timeit ( stmt = fast , number = 1000000 ))","title":"GOOD"},{"location":"Coding/Python/anti-patterns/#not-following-pep8","text":"Last but not least, not following PEP8 is one of the worst crimes against python you can make. Carl... If you do this.. You're DEAD to me! PEP 8 -- Style Guide for Python Code | Python.org","title":"Not following PEP8"},{"location":"Coding/Python/decorating/","text":"Decorating This is a VERY quick primer on decorators in python. Specifically what they are and how to create a few different types. I'll also try to add a few real world examples.. if I'm not too lazy. If you want a more detailed explanation, I recommend this site. What's a Decorator? No Carl, we're not talking about the person you hire to decorate for your wedding or a party. A python decorator, by definition, is a function that takes another function as it's argument (wrapping it) and modifies the behavior or response of the \"decorated\" function, without explicitly modifying it. Confused yet? Yeah me too! Let's break that down. First it's a function, that's easy enough. Second, you pass another function to it as an argument.. ok, sure.. but you're probably asking \"what does that look like?\" We'll get there. Functions are First Class Citizens Now, I know what you're thinking Carl.. but do I really need 2 tongues . To understand how decorators work, you need to understand one important concept Python\u2019s Functions Are First-Class objects . This means a function can be passed around to other functions as an argument (kind of like a function pointer in other languages). 1 2 3 4 5 6 7 8 9 10 def foo ( func ): print ( \"Entering Decorator\" ) func () # Call the function print ( \"Leaving Decorator\" ) def bar (): print ( \"Bar is running\" ) # Call foo with bar foo ( bar ) The next thing you're probably asking yourself is.. What if I still want to call bar () in my code and not have to go and update everything to call foo ( bar ) ? You're getting ahead of me Carl! Take a chill pill. Inner Functions The next important thing to know is that in Python you can define a function in a function.. 1 2 3 4 5 6 def foo (): def bar (): print ( \"In Bar\" ) # Call foo foo () Note The above does pretty much nothing, since bar is never actually called. You can also return a function from a function (even an inner function).. and unlike some programs, your code won't crash when the outer function goes out of scope . 1 2 3 4 5 6 7 8 9 10 def foo (): def bar (): print ( \"In Bar\" ) return bar # Call foo.. which returns bar test = foo () # Calling test is the same as calling the inner function bar() test () Pretty cool, huh? Basic Function Wrapper Sweet As! Now that you understand that functions are first class citizens in the world of python and that they can be passed around like a joint at a party any other object in python. And you understand how a function can return an inner function, you're now ready to take the blue pill and see how far this decorating rabbit hole really goes. This is a simple example of how we can use one function to wrap another 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def foo ( func ): def wrapper (): print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper def bar (): print ( \"Bar is running\" ) # Wrap bar with foo test = foo ( bar ) # Run bar test () Pretty sweet, huh? We have now wrapped bar with foo in such a way that we now can modify bar 's behavior/response. Pour Some Sugar on Me! Now.. the next question, can we make this easier and even more awesome? And the answer is YEP! Python offers some sweet syntactic sugar to make decorating even better! Python has a cool feature called the \"pie\" syntax, which allows us to condense the above example into this: 1 2 3 4 5 6 7 8 9 10 11 12 13 def foo ( func ): def wrapper (): print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper @foo def bar (): print ( \"Bar is running\" ) # Run bar bar () Note Notice the @ symbol above the definition of bar this is the \"pie\" syntax and when we use it this way, we are telling Python to decorate our function using the function name direcly to the right of the @ Decorating Classes Hey Carl, want to know a secret? Yeah of course you do! Well here it is.. You can can decorate more than just simple functions. You can also decorate class methods and even... entire classes. Decorating Class Methods Decorating a class method is the same as the basic decorators discussed above. A real world example of this would be the @staticmethod and @classmethod decorators. Note The @staticmethod and @classmethod allow you define methods in the class namespace that do not directly rely on a instance of the class 1 2 3 4 5 6 7 8 9 class Foo ( object ): @classmethod def test ( cls ): print ( \"Running Foo classmethod\" ) return cls () @staticmethod def static_test (): print ( \"Running Foo.static_test\" ) Note To define a decorate to use on a method in a class, follow the same steps above for Basic function decorators. Decorating Classes The second type of class decorator is one that decorates the entire class. When you decorate an entire class, you're actually decorating the __init__ method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def foo ( klass ): def wrapper ( * args , ** kwargs ): return klass ( name = \"Inigo Montoya\" ) return wrapper @foo # Decorating the Bar class class Bar ( object ): def __init__ ( self , name : str = \"\" ): self . name = name def who_am_i ( self ): print ( \"Hello! My name is {} \" . format ( self . name )) # Call with `Foo` as the name test = Bar ( name = \"foo\" ) test . who_am_i () Note Carl, if you're asking who Inigo Montoya is... Get the hell off my site! Advanced Usage (Fancy Stuff) Maintaining Docstrings One of the unfortunate things about using decorators is that you lose any help documentation from the \"decorated\" function. Take this for example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def foo ( func ): \"\"\"Function Decorator\"\"\" def wrapper (): \"\"\"Inner wrapper. The user doesn't care about this\"\"\" print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper @foo def bar (): \"\"\"Super cool function that does amazing things!\"\"\" print ( \"Bar is running\" ) help ( bar ) This will give you the help docstring for the wrapper , which is definitely not what we want. Instead we want the docstring for bar This is where functools comes to the rescue! Specifically the wraps decorator. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from functools import wraps def foo ( func ): \"\"\"Function Decorator\"\"\" @wraps ( func ) def wrapper (): \"\"\"Inner wrapper. The user doesn't care about this\"\"\" print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper @foo def bar (): \"\"\"Super cool function that does amazing things!\"\"\" print ( \"Bar is running\" ) help ( bar ) Now that's more like it! As you can see if you run the above code, you're now getting the docstring from bar when you use help and not the inner wrapper. Real World Examples (Things I've actually written) Sorry.. too lazy to put anything in here just yet. Maybe later.","title":"Decorating"},{"location":"Coding/Python/decorating/#decorating","text":"This is a VERY quick primer on decorators in python. Specifically what they are and how to create a few different types. I'll also try to add a few real world examples.. if I'm not too lazy. If you want a more detailed explanation, I recommend this site.","title":"Decorating"},{"location":"Coding/Python/decorating/#whats-a-decorator","text":"No Carl, we're not talking about the person you hire to decorate for your wedding or a party. A python decorator, by definition, is a function that takes another function as it's argument (wrapping it) and modifies the behavior or response of the \"decorated\" function, without explicitly modifying it. Confused yet? Yeah me too! Let's break that down. First it's a function, that's easy enough. Second, you pass another function to it as an argument.. ok, sure.. but you're probably asking \"what does that look like?\" We'll get there.","title":"What's a Decorator?"},{"location":"Coding/Python/decorating/#functions-are-first-class-citizens","text":"Now, I know what you're thinking Carl.. but do I really need 2 tongues . To understand how decorators work, you need to understand one important concept Python\u2019s Functions Are First-Class objects . This means a function can be passed around to other functions as an argument (kind of like a function pointer in other languages). 1 2 3 4 5 6 7 8 9 10 def foo ( func ): print ( \"Entering Decorator\" ) func () # Call the function print ( \"Leaving Decorator\" ) def bar (): print ( \"Bar is running\" ) # Call foo with bar foo ( bar ) The next thing you're probably asking yourself is.. What if I still want to call bar () in my code and not have to go and update everything to call foo ( bar ) ? You're getting ahead of me Carl! Take a chill pill.","title":"Functions are First Class Citizens"},{"location":"Coding/Python/decorating/#inner-functions","text":"The next important thing to know is that in Python you can define a function in a function.. 1 2 3 4 5 6 def foo (): def bar (): print ( \"In Bar\" ) # Call foo foo () Note The above does pretty much nothing, since bar is never actually called. You can also return a function from a function (even an inner function).. and unlike some programs, your code won't crash when the outer function goes out of scope . 1 2 3 4 5 6 7 8 9 10 def foo (): def bar (): print ( \"In Bar\" ) return bar # Call foo.. which returns bar test = foo () # Calling test is the same as calling the inner function bar() test () Pretty cool, huh?","title":"Inner Functions"},{"location":"Coding/Python/decorating/#basic-function-wrapper","text":"Sweet As! Now that you understand that functions are first class citizens in the world of python and that they can be passed around like a joint at a party any other object in python. And you understand how a function can return an inner function, you're now ready to take the blue pill and see how far this decorating rabbit hole really goes. This is a simple example of how we can use one function to wrap another 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def foo ( func ): def wrapper (): print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper def bar (): print ( \"Bar is running\" ) # Wrap bar with foo test = foo ( bar ) # Run bar test () Pretty sweet, huh? We have now wrapped bar with foo in such a way that we now can modify bar 's behavior/response.","title":"Basic Function Wrapper"},{"location":"Coding/Python/decorating/#pour-some-sugar-on-me","text":"Now.. the next question, can we make this easier and even more awesome? And the answer is YEP! Python offers some sweet syntactic sugar to make decorating even better! Python has a cool feature called the \"pie\" syntax, which allows us to condense the above example into this: 1 2 3 4 5 6 7 8 9 10 11 12 13 def foo ( func ): def wrapper (): print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper @foo def bar (): print ( \"Bar is running\" ) # Run bar bar () Note Notice the @ symbol above the definition of bar this is the \"pie\" syntax and when we use it this way, we are telling Python to decorate our function using the function name direcly to the right of the @","title":"Pour Some Sugar on Me!"},{"location":"Coding/Python/decorating/#decorating-classes","text":"Hey Carl, want to know a secret? Yeah of course you do! Well here it is.. You can can decorate more than just simple functions. You can also decorate class methods and even... entire classes.","title":"Decorating Classes"},{"location":"Coding/Python/decorating/#decorating-class-methods","text":"Decorating a class method is the same as the basic decorators discussed above. A real world example of this would be the @staticmethod and @classmethod decorators. Note The @staticmethod and @classmethod allow you define methods in the class namespace that do not directly rely on a instance of the class 1 2 3 4 5 6 7 8 9 class Foo ( object ): @classmethod def test ( cls ): print ( \"Running Foo classmethod\" ) return cls () @staticmethod def static_test (): print ( \"Running Foo.static_test\" ) Note To define a decorate to use on a method in a class, follow the same steps above for Basic function decorators.","title":"Decorating Class Methods"},{"location":"Coding/Python/decorating/#decorating-classes_1","text":"The second type of class decorator is one that decorates the entire class. When you decorate an entire class, you're actually decorating the __init__ method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def foo ( klass ): def wrapper ( * args , ** kwargs ): return klass ( name = \"Inigo Montoya\" ) return wrapper @foo # Decorating the Bar class class Bar ( object ): def __init__ ( self , name : str = \"\" ): self . name = name def who_am_i ( self ): print ( \"Hello! My name is {} \" . format ( self . name )) # Call with `Foo` as the name test = Bar ( name = \"foo\" ) test . who_am_i () Note Carl, if you're asking who Inigo Montoya is... Get the hell off my site!","title":"Decorating Classes"},{"location":"Coding/Python/decorating/#advanced-usage-fancy-stuff","text":"Maintaining Docstrings One of the unfortunate things about using decorators is that you lose any help documentation from the \"decorated\" function. Take this for example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def foo ( func ): \"\"\"Function Decorator\"\"\" def wrapper (): \"\"\"Inner wrapper. The user doesn't care about this\"\"\" print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper @foo def bar (): \"\"\"Super cool function that does amazing things!\"\"\" print ( \"Bar is running\" ) help ( bar ) This will give you the help docstring for the wrapper , which is definitely not what we want. Instead we want the docstring for bar This is where functools comes to the rescue! Specifically the wraps decorator. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from functools import wraps def foo ( func ): \"\"\"Function Decorator\"\"\" @wraps ( func ) def wrapper (): \"\"\"Inner wrapper. The user doesn't care about this\"\"\" print ( \"Entering Decorator\" ) func () print ( \"Leaving Decorator\" ) return wrapper @foo def bar (): \"\"\"Super cool function that does amazing things!\"\"\" print ( \"Bar is running\" ) help ( bar ) Now that's more like it! As you can see if you run the above code, you're now getting the docstring from bar when you use help and not the inner wrapper.","title":"Advanced Usage (Fancy Stuff)"},{"location":"Coding/Python/decorating/#real-world-examples-things-ive-actually-written","text":"Sorry.. too lazy to put anything in here just yet. Maybe later.","title":"Real World Examples (Things I've actually written)"},{"location":"Jira/jira_queries/","text":"Useful JQL Snippets Open tickets that haven't been updated in N days Query for all Open tickets in given projects that have not been updated (touched in anyway) in more than N days (365 in this case) 1 project in ( X , Y , Z ) AND updated < - 365 d AND status not in ( Closed , Resolved ) ORDER BY updated DESC Query all tickets which are linked to tickets in another project 1 project in ( X , Y ) AND issueFunction in linkedIssuesOf ( \"project = Z\" )","title":"Useful JQL Snippets"},{"location":"Jira/jira_queries/#useful-jql-snippets","text":"","title":"Useful JQL Snippets"},{"location":"Jira/jira_queries/#open-tickets-that-havent-been-updated-in-n-days","text":"Query for all Open tickets in given projects that have not been updated (touched in anyway) in more than N days (365 in this case) 1 project in ( X , Y , Z ) AND updated < - 365 d AND status not in ( Closed , Resolved ) ORDER BY updated DESC","title":"Open tickets that haven't been updated in N days"},{"location":"Jira/jira_queries/#query-all-tickets-which-are-linked-to-tickets-in-another-project","text":"1 project in ( X , Y ) AND issueFunction in linkedIssuesOf ( \"project = Z\" )","title":"Query all tickets which are linked to tickets in another project"},{"location":"Life/movies_everyone_should_watch/","text":"Movies Everyone Should Watch (Maybe) Hey Carl, this is a fun one. This is a list of movies that I believe everyone should watch at least once. There is no order to this list. A movie being higher on the page doesn't mean it's better or worse than any other. Also.. take note that I didn't say all of these movies are necessarily \"good.\" Some can be pretty awful; but you should still watch them Carl. You'll thank me once you do.. or maybe you won't. Toy Story Series (even the 4th one which is way better than it has any right to be) The Incredibles Finding Nemo Monster's Inc Up Wall-E Inside Out Coco Avatar The Abyss The Usual Subjects Hackers Anti-Trust Hudson Hawk The Producers (Original and Remake) . (First Rule of Fight Club) Aladdin (Animated Version) Alien Aliens Alita Battle Angel Beauty and the Beast (Disney Animated Version) Blazing Saddles Deadpool (1 and 2) Die Hard (One of the best Christmas movies of all time) Galaxy Quest Guardians of the Galaxy Lord of the Rings (Weta Version) Hot Fuzz How to Train your Dragon Inception Indiana Jones (1 through 3) The Iron Giant John Wick (All of them) Jurassic Park The Little Mermaid (Disney Animated Version) Mary Poppins The Matrix (First one only) Men In Black (First one only) Moana Monty Python and the search for the Holy Grail Morning Light The Mummy (First one) Pirates of the Caribbean The Right Stuff The Princess Bride Real Genius The Reduced Shakespeare Company Robin Hood Men In Tights Sahara Schindler's List Serenity Shaun of the Dead Shazam! The Secret Life of Walter Mitty Social Network Spaceballs Star Wars (4,5,6) Stargate Starship Troopers Operation Takedown Tangled TMNT (1 and 2) Terminator (1 and 2) Titan AE The Thomas Crown Affair Tomorrowland Tron WarGames Logan Who Framed Roger Rabbit Willy Wonka and the Chocolate Factory The World's End Young Frankenstein Dark Knight Trilogy The Muppet Movie Jaw ET Groundhog Day The Shining The Shawshank Redemption The Lion King Titanic Forrest Gump One Flew Over the Cuckoo's Nest Dead Poets Society Home Alone An American Tail: Fievel Goes West Gremlins Catch Me If You Can Blade Runner Silence of the Lambs Spider-Man: Into the Spider-Verse Iron Man Ratatouille Back to the Future Trilogy Casablanca Whiplash Slumdog Millionaire A Few Good Men The Martian The Sting Zombieland The King's Speech Office Space Ferris Bueller's Day Off The Breakfast Club Full Metal Jacket Chinatown The Thing (1982) Argo (fuck yourself)","title":"Movies Everyone Should Watch (Maybe)"},{"location":"Life/movies_everyone_should_watch/#movies-everyone-should-watch-maybe","text":"Hey Carl, this is a fun one. This is a list of movies that I believe everyone should watch at least once. There is no order to this list. A movie being higher on the page doesn't mean it's better or worse than any other. Also.. take note that I didn't say all of these movies are necessarily \"good.\" Some can be pretty awful; but you should still watch them Carl. You'll thank me once you do.. or maybe you won't. Toy Story Series (even the 4th one which is way better than it has any right to be) The Incredibles Finding Nemo Monster's Inc Up Wall-E Inside Out Coco Avatar The Abyss The Usual Subjects Hackers Anti-Trust Hudson Hawk The Producers (Original and Remake) . (First Rule of Fight Club) Aladdin (Animated Version) Alien Aliens Alita Battle Angel Beauty and the Beast (Disney Animated Version) Blazing Saddles Deadpool (1 and 2) Die Hard (One of the best Christmas movies of all time) Galaxy Quest Guardians of the Galaxy Lord of the Rings (Weta Version) Hot Fuzz How to Train your Dragon Inception Indiana Jones (1 through 3) The Iron Giant John Wick (All of them) Jurassic Park The Little Mermaid (Disney Animated Version) Mary Poppins The Matrix (First one only) Men In Black (First one only) Moana Monty Python and the search for the Holy Grail Morning Light The Mummy (First one) Pirates of the Caribbean The Right Stuff The Princess Bride Real Genius The Reduced Shakespeare Company Robin Hood Men In Tights Sahara Schindler's List Serenity Shaun of the Dead Shazam! The Secret Life of Walter Mitty Social Network Spaceballs Star Wars (4,5,6) Stargate Starship Troopers Operation Takedown Tangled TMNT (1 and 2) Terminator (1 and 2) Titan AE The Thomas Crown Affair Tomorrowland Tron WarGames Logan Who Framed Roger Rabbit Willy Wonka and the Chocolate Factory The World's End Young Frankenstein Dark Knight Trilogy The Muppet Movie Jaw ET Groundhog Day The Shining The Shawshank Redemption The Lion King Titanic Forrest Gump One Flew Over the Cuckoo's Nest Dead Poets Society Home Alone An American Tail: Fievel Goes West Gremlins Catch Me If You Can Blade Runner Silence of the Lambs Spider-Man: Into the Spider-Verse Iron Man Ratatouille Back to the Future Trilogy Casablanca Whiplash Slumdog Millionaire A Few Good Men The Martian The Sting Zombieland The King's Speech Office Space Ferris Bueller's Day Off The Breakfast Club Full Metal Jacket Chinatown The Thing (1982) Argo (fuck yourself)","title":"Movies Everyone Should Watch (Maybe)"},{"location":"Linux/debugging/","text":"General debugging tips or commands for Linux Get a list of linked libraries for a specific process ID 1 grep fbx /proc/ { PID } /maps GDB Commands Command The command keyword will allow you to run a command each time a break is hit. 1 2 3 4 ( gdb ) command 1 >print addr >print len >end Setting source code You can set the location of the source you are debugging with the directory keyword. 1 ( gdb ) directory /location/of/source/code/cpp Printing a boost::shared_ptr 1 2 3 ( gdb ) set print pretty ( gdb ) print { variable } .px ( gdb ) print $1 -> { method }","title":"General debugging tips or commands for Linux"},{"location":"Linux/debugging/#general-debugging-tips-or-commands-for-linux","text":"","title":"General debugging tips or commands for Linux"},{"location":"Linux/debugging/#get-a-list-of-linked-libraries-for-a-specific-process-id","text":"1 grep fbx /proc/ { PID } /maps","title":"Get a list of linked libraries for a specific process ID"},{"location":"Linux/debugging/#gdb-commands","text":"","title":"GDB Commands"},{"location":"Linux/debugging/#command","text":"The command keyword will allow you to run a command each time a break is hit. 1 2 3 4 ( gdb ) command 1 >print addr >print len >end","title":"Command"},{"location":"Linux/debugging/#setting-source-code","text":"You can set the location of the source you are debugging with the directory keyword. 1 ( gdb ) directory /location/of/source/code/cpp","title":"Setting source code"},{"location":"Linux/debugging/#printing-a-boostshared_ptr","text":"1 2 3 ( gdb ) set print pretty ( gdb ) print { variable } .px ( gdb ) print $1 -> { method }","title":"Printing a boost::shared_ptr"},{"location":"Linux/VIM/commands/","text":"Useful VIM Commands Switch to tabs instead of spaces If you're working on someone else's code.. and they're monsters who use tabs.. then this command will switch your VIM to tab mode 1 2 3 :set tabstop=4 \" To match the sample file :set noexpandtab \" Use tabs, not spaces :%retab!","title":"Useful VIM Commands"},{"location":"Linux/VIM/commands/#useful-vim-commands","text":"","title":"Useful VIM Commands"},{"location":"Linux/VIM/commands/#switch-to-tabs-instead-of-spaces","text":"If you're working on someone else's code.. and they're monsters who use tabs.. then this command will switch your VIM to tab mode 1 2 3 :set tabstop=4 \" To match the sample file :set noexpandtab \" Use tabs, not spaces :%retab!","title":"Switch to tabs instead of spaces"}]}